options {
    LOOKAHEAD = 2;
}
PARSER_BEGIN(Evaluator)

import java.util.LinkedHashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class Evaluator {

    public static LinkedHashMap LookupTable = new LinkedHashMap();

    public static void main(String[] args) {
        try {
            Evaluator evaluator = new Evaluator(new java.io.StringReader(args[0]));
	    int numvars = countvars(args[0]);
	    String mappings = "";

	    // Based on how we implemented successor
	    for(int i = 0; i < numvars; i++){
		mappings = mappings.concat("F");
	    }

	    do{
                populateTable(args[0], mappings);
                System.out.println(evaluator.S());
                evaluator.ReInit(new java.io.StringReader(args[0]));
		mappings = successor(mappings);
	    } while(!mappings.equals(""));
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Failed: " + e.getMessage());
        }
    }

    public static int countvars(String exp){
	Pattern pattern = Pattern.compile("[A-E[G-S[U-Z]]]");
	Matcher matcher = pattern.matcher(exp);
	int count = 0;
	String seenvars = "";

	while(matcher.find()){
	    // .contains needs a CharSequence, which can be made by doing c+"" for a char c
	    if(!seenvars.contains(exp.charAt(matcher.start())+"")){
	        count++;
		seenvars = seenvars.concat(exp.substring(matcher.start(), matcher.start()+1));
	    }
        }
	return count;
    }

    public static void populateTable(String exp, String bindings){
    // [A-Z] is a character class for pattern which specifies A through Z
	boolean boolv = true;
	int count = 0;
	Pattern pattern = Pattern.compile("[A-E[G-S[U-Z]]]");
	Matcher matcher = pattern.matcher(exp);

        while(matcher.find()){

          String var = exp.substring(matcher.start(), matcher.start()+1);

          if(LookupTable.get(var)==null){
	      boolv = (bindings.charAt(count)=='T')? true : false;
              LookupTable.put(var, boolv);
	      count++;
          }
        }
    }

    // Given a set of bindings, return the next set of bindings
    // Ex: TFF returns TFT
    public static String successor(String bindings){
        bindings = bindings.replace('T', '1');
        bindings = bindings.replace('F', '0');
        int value = Integer.parseInt(bindings, 2);
        value++;

        if(value >= 8){
            // Cannot return past TTT
            return "";
        }
        else{
            String newbindings = Integer.toString(value);
            newbindings = newbindings.replace('1', 'T');
            newbindings = newbindings.replace('0', 'F');
            return newbindings;
        }
    }
}

PARSER_END(Evaluator)

SKIP:  { " " | "\t" | "\n" | "\r" } // Skip whitespace
TOKEN: { "(" | ")" | "&&" | "||" | "->" | "<-" | "<->" | "!" | <VAR : (["A"-"E", "G"-"S", "U"-"Z"])> | <BOOL: (["T", "F"])> }

boolean S():{ boolean result; } {
    result = BIJ() <EOF> {
        return result;
    }
}

boolean BIJ(): { boolean result, rhs; } {
    result = IMP() ("<->" rhs = BIJ() { result = result && rhs || !result && !rhs; } )* {
        return result;
    }
}

boolean IMP(): { boolean result, rhs; } {
    result = OR() ("->"  rhs = IMP() { result = !result || rhs; } )* {
        return result;
    }
}

boolean OR(): { boolean result, rhs; } {
    result = AND() ("||"  rhs = OR() { result = result || rhs; } )* {
        return result;
    }
}

boolean AND(): { boolean result, rhs; } {
    result = NOT() ("&&" rhs = AND() { result = result && rhs; } )* {
        return result;
    }
}

boolean NOT(): { boolean result; } {
    "!" result = BOOL() {
        return !result;
    }
    | result = BOOL() {
        return result;
    }
}

boolean BOOL(): { Token n; boolean result; } {
    n = <VAR> {
        return (boolean)Evaluator.LookupTable.get(n.image);
    }
    | n = <BOOL> {
        if(n.image.equals("T"))
            return true;
        return false;
    }
    | "(" result = BIJ() ")" {
        return result;
    }
}

