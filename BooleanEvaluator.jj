options {
    LOOKAHEAD = 2;
}
PARSER_BEGIN(Evaluator)

import java.util.LinkedHashMap;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class Evaluator {

    /* Constants */
    public static final String FALSE    = "F";
    public static final String TRUE     = "T";
    public static final String END_STR  = "";

    /* Mappings for variables in boolean expression */
    public static LinkedHashMap LookupTable = new LinkedHashMap();

    public static void main(String[] args) {
        try {
            /* Local variables */
            String    expression    = args[0];
            Evaluator evaluator     = new Evaluator(new java.io.StringReader(expression));
            int       num_vars      = count_vars(expression);
            String    mappings      = ""; // TODO: Is this necessary?

            /* Initialize mappings to a string of all F */
            for(int i = 0; i < num_vars; i++)
                mappings = mappings.concat("F");
            while(mappings.equals(END_STR) == false) {
                System.out.println(mappings);
                populateTable(expression, mappings);
                System.out.println(evaluator.S());
                evaluator.ReInit(new java.io.StringReader(expression));
                mappings = successor(mappings, num_vars);
            }
        }
        catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Fatal exception: " + e.getMessage());
        }
    }

    public static int count_vars(String exp) {
        /* Local variable declarations */
        Pattern pattern     = Pattern.compile("[A-E[G-S[U-Z]]]");
        Matcher matcher     = pattern.matcher(exp);
        int count           = 0;
        String seen_vars    = "";

        while(matcher.find()) {
            if(seen_vars.contains(matcher.group()) == false) {
                ++count;
                seen_vars = seen_vars.concat(matcher.group());
            }
        }
        return count;
    }

    // TODO: please fix this, Eysa
    public static void populateTable(String exp, String bindings) {
        boolean boolv   = true;
        int     count   = 0;
        Pattern pattern = Pattern.compile("[A-E[G-S[U-Z]]]");
        Matcher matcher = pattern.matcher(exp);
        String  var     = "";

        while(matcher.find()) {
            var = matcher.group();
            if(LookupTable.get(var) == null) {
                boolv = bindings.charAt(count++) == 'T';
                LookupTable.put(var, boolv);
            }
        }
    }

    /* Successor returns the next binding string in binary counting order */
    /* Returns "" on overflow */
    public static String successor(String bindings, int num_vars) {
        bindings = bindings.replace('T', '1');
        bindings = bindings.replace('F', '0');
        int value = Integer.parseInt(bindings, 2);
        ++value;

        if(value >= java.lang.Math.pow(2, num_vars))
            return "";
        else {
            return String.format("%" + num_vars + "s", Integer.toBinaryString(value)).replace(' ', '0').replace('1', 'T').replace('0', 'F');
        }
    }

}

PARSER_END(Evaluator)

SKIP:  { " " | "\t" | "\n" | "\r" } // Skip whitespace
TOKEN: { "(" | ")" | "&&" | "||" | "->" | "<-" | "<->" | "!" | <VAR : (["A"-"E", "G"-"S", "U"-"Z"])> | <BOOL: (["T", "F"])> }

boolean S():{ boolean result; } {
    result = EQ() <EOF> {
        return result;
    }
}

boolean EQ(): { boolean result, rhs; } {
    result = IMP() ("<->" rhs = EQ() { result = result && rhs || !result && !rhs; } )* {
        return result;
    }
}

boolean IMP(): { boolean result, rhs; } {
    result = OR() ("->"  rhs = IMP() { result = !result || rhs; } )* {
        return result;
    }
}

boolean OR(): { boolean result, rhs; } {
    result = AND() ("||"  rhs = OR() { result = result || rhs; } )* {
        return result;
    }
}

boolean AND(): { boolean result, rhs; } {
    result = NOT() ("&&" rhs = AND() { result = result && rhs; } )* {
        return result;
    }
}

boolean NOT(): { boolean result; } {
    "!" result = BOOL() {
        return !result;
    }
    | result = BOOL() {
        return result;
    }
}

boolean BOOL(): { Token n; boolean result; } {
    n = <VAR> {
        return (boolean)Evaluator.LookupTable.get(n.image);
    }
    | n = <BOOL> {
        if(n.image.equals("T"))
            return true;
        return false;
    }
    | "(" result = EQ() ")" {
        return result;
    }
}

